mod module;

pub fn load_module() {
  WebsiteModule::to_module(1, "manganato", "https://manganato.com")
}

pub struct WebsiteModule {
  client,
  name_regex,
  
  from_rust
}

impl WebsiteModule {
  pub fn new() {
    let reg = mado::regex::Regex::compile("(?x)
      # Get volume (optional)
      (Vol.(?P<vol>\\d+)\\s+?)?
      # Get Chapter
      (Chapter\\s+?(?P<ch>\\d+))

      # Get Title (optional)
      ((\\s+)?:(\\s+)?
      (?P<title>.*))?
    ");

    Self { 
      name_regex: reg, 
      client: mado::http::Client::default_(), 
      from_rust: Self::from_rust 
    }
  }

  pub fn to_module(id,name,domain) {
    module::new(
      id, name, domain, Self::new(),
      #{
         get_info: Self::get_info,
         get_chapter_images: Self::get_chapter_images,
      }
    )
  }

  pub fn from_rust(data) {
    Self {
      client: data.client,
      name_regex: data.name_regex,
      from_rust: Self::from_rust
    }
  }

  pub async fn get_info(self, url) {
    let response = self.client.get(url.clone()).send().await.unwrap().text().await;

    let doc = mado::html::Document::new(response);

    let info = self.parse_info(url, doc)?;

    info.chapters = [];
    let chapters = doc.find("ul.row-content-chapter>li");
    for it in chapters.iter() {
      info.chapters.push(self.parse_chapter(it));
    }
    info.chapters.reverse();

    Ok(info)
  }

  pub fn parse_info(self, url, doc) {
    if doc.find("div.panel-not-found").len() != 0 {
      return Err(mado::error::Error::request_error(url, "404 not found"));
    }

    let info = #{};

    let find = |key, attr| {
      doc.find(key).attr(attr).map(|v| v.to_string())
    };


    let property = |key| {
      find(`meta[property='og:${key}']`, "content")
    };

    info.title = doc.find("h1").text().to_string();

    info.cover_link = property("image");
    let summary = doc.find("div.panel-story-info-description");
    // remove <h3>Description :</h3>
    summary.children().first().remove();
    info.summary = summary.text().to_string().trim();

    let find_info = |key| {
      doc.find(key)
        .parent()
        .parent()
        .find("td.table-value")
        .find("a")
        .iter()
        .map(|v| v.text().to_string())
        .collect_vec()
    };
    info.genres = find_info("i.info-genres");
    info.authors = find_info("i.info-author");
    info.artists = [];
    info.types = "Series";

    Ok(info)
  }

  pub fn parse_chapter(self, doc) {
    let info = #{};
    let reg = mado::regex::Regex::compile("(?x)
      (Vol.(?P<vol>\\d+)\\s+?)?
      (Chapter\\s+?(?P<ch>\\d+))
      ((\\s+)?:(\\s+)?(?P<title>.*))?
    ");

    info.title = doc.find("a").text().to_string();
    info.id = doc.find("a").attr("href").unwrap().to_string();
    info.volume = None;
    info.chapter = None;
    info.language = "en";

    let cap = reg.captures(info.title.clone());
    if let Some(cap) = cap {
      info.chapter = cap.name("ch");
      info.volume = cap.name("vol");
      info.title = cap.name("title").unwrap_or(info.title);
    }

    info
  }

  async fn get_chapter_images(self, id, task) {
    use mado::http::Url;

    let response = self.client
      .get(Url::parse(id).unwrap())
      .send()
      .await?;

    let html = mado::html::Document::new(response.text().await);

    let queries = [
      #{ find: "div#vungdoc>img" },
      #{ find: "div#vungdoc>img", src: "data-src" },
      #{ find: "div.vung_doc>img" },
      #{ find: "div.container-chapter-reader>img" },
    ];
    let src = "src";
    let title = "title";

    let images = [];

    for query in queries {
      images = html.find(query.find)
        .iter()
        .map(|img| self.parse_image(query, img))
        .filter(|(k, v)| k.is_some() && v.is_some())
        .map(|(k, v)| (k.unwrap(), v.unwrap()));
    }

    for (title, src) in images {
      dbg(src);
    }
  }

  fn parse_image(self, query, img) {
    let get = |name| {
      let attr = query.get(name).unwrap_or(name);
      img.attr(attr).map(|v| v.to_string())
    };

    let title = get("title");
    let src = get("src");
    (title, src)
  }

}

mod test {
  use mado::http::Url;
  use super::*;
  mod mock;

  pub fn create_module() {
    super::load_module().data
  }

  #[test]
  pub async fn get_info() {
    let module = create_module();
    let url = Url::parse("https://manganato.com/manga-yu976355").unwrap();
    let info = module.get_info(url).await;

    info
  }

  #[test]
  pub async fn get_info_404() {
    let module = create_module();
    let url = Url::parse("https://manganato.com/manga-yu176355").unwrap();
    let info = module.get_info(url).await;

    match info {
      Ok(info) => {
        panic(`expected error found: ${info}`);
      }
      Err(err) => {
        assert_eq!(err.to_string_variant(), "RequestError");
      }
      _ => {
        panic("Expected Result");
      }
    }
  }

  #[test]
  pub async fn get_chapter_image_test() {
    let module = create_module();
    let url = Url::parse("https://manganato.com/manga-yu976355").unwrap();
    let info = module.get_info(url)
      .await
      .expect("expecting Ok");
    let task = mock::ChapterTaskMock::new(info.chapters.iter().map(|v| v.id));

    let id = info.chapters.get(0).expect("expecting manga with chapter").id;
    let result = module.get_chapter_images(id, task).await;
  }

}
